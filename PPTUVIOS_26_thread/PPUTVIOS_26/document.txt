

parsePAT(uint8_t *buffer){
    tablePAT.sectionLength=(uint16_t)(((*(buffer+1)<<8)+*(buffer + 2)) & 0x0FFF);
    tablePAT.transportStream=(uint16_t)(((*(buffer+3)<<8)+*(buffer + 4)));
    tablePAT.versionNumber=(uint8_t)((*(buffer+5)>>1)& 0x1F);
    
    channelCount=(tablePAT.sectionLength*8-64)/32;
    int i=0;
    
    for(;i<channelCount;i++){
        tablePAT.programNumber[i]=(uint16_t)(*(buffer+(i*4)+8)<<8)+(*(buffer+(i*4)+9));
        tablePAT.PID[i]=(uint16_t)((*(buffer+(i*4)+10)<<8)+(*(buffer+(i*4)+11)) & 0x1FFF);
        printf("%d\tpid: %d\n", tablePAT.programNumber[i], tablePAT.PID[i]);
    }
    printf("\n\nSection arrived!!!\nsection length: %d\nts ID: %d\nversion number: %d\nchannel number: %d\n", tablePAT.sectionLength, tablePAT.transportStream, tablePAT.versionNumber, channelCount);
}

parsePMT(uint8_t *buffer){
    parseFlag=0;
        tablePMT[i].sectionLength=(uint16_t)(((*(buffer+1)<<8)+*(buffer + 2)) & 0x0FFF);
        tablePMT[i].programNumber=(uint16_t)((*(buffer+3)<<8)+*(buffer + 4));
        tablePMT[i].programInfoLength=(uint16_t)(((*(buffer+10)<<8)+*(buffer + 11))& 0x0FFF);
        tablePMT[i].streamCount=0;

        tablePMT[i].hasTTX=0;
        int j;

        printf("\n\nSection arrived!!! PMT: %d \t%d\t%d\n", tablePMT[i].sectionLength, tablePMT[i].programNumber, tablePMT[i].programInfoLength);

        uint8_t *m_buffer = (uint8_t*)buffer + 12 + tablePMT[i].programInfoLength;

        for ( j = 0; ((uint16_t)(m_buffer-buffer)+5<tablePMT[i].sectionLength); j++)
        {

            tablePMT[i].streams[j].streamType=*(m_buffer);
            tablePMT[i].streams[j].elementaryPID=(uint16_t)((*(m_buffer+1)<<8) + *(m_buffer+2)) & 0x1FFF;
            tablePMT[i].streams[j].esInfoLength=(uint16_t)((*(m_buffer+3)<<8) + *(m_buffer+4)) & 0x0FFF;
            tablePMT[i].streams[j].descriptor=(uint8_t)*(m_buffer+5);

            // find audio stream
            if(tablePMT[i].streams[j].streamType==3){
                tablePMT[i].audioPID=tablePMT[i].streams[j].elementaryPID;
            }
            else if(tablePMT[i].streams[j].streamType==2){
                tablePMT[i].videoPID=tablePMT[i].streams[j].elementaryPID;
            }

            if(tablePMT[i].streams[j].streamType==6 && tablePMT[i].streams[j].descriptor==86)
                tablePMT[i].hasTTX=1;

            printf("streamtype: %d epid: %d len %d desc: %d\n", tablePMT[i].streams[j].streamType, tablePMT[i].streams[j].elementaryPID, tablePMT[i].streams[j].esInfoLength, tablePMT[i].streams[j].descriptor);
            m_buffer+= 5 + tablePMT[i].streams[j].esInfoLength;
            tablePMT[i].streamCount++;
        }
        printf("%d\thasTTX: %d", tablePMT[i].streamCount, tablePMT[i].hasTTX);
}

int32_t mySecFilterCallback(uint8_t *buffer){

    uint8_t tableId = *buffer; 
    if(tableId==0x00){
        parsePAT(buffer);
    }
    else if(tableId==0x02){
        parsePMT(buffer);
    }
    return 0;
}

void changeChannel(int channel){
    int videoPID, audioPID;

    audioPID = tablePMT[channel].audioPID;
    videoPID = tablePMT[channel].videoPID;

    if(videoStreamHandle){
            Player_Stream_Remove(playerHandle, sourceHandle, videoStreamHandle);
            videoStreamHandle=0;
    }
    Player_Stream_Remove(playerHandle, sourceHandle, audioStreamHandle);

    if(videoPID){
        Player_Stream_Create(playerHandle, sourceHandle, videoPID, VIDEO_TYPE_MPEG2, &videoStreamHandle);
        Player_Stream_Create(playerHandle, sourceHandle, audioPID, AUDIO_TYPE_MPEG_AUDIO, &audioStreamHandle);
    }
    else{
        videoStreamHandle=0;
        Player_Stream_Create(playerHandle, sourceHandle, audioPID, AUDIO_TYPE_MPEG_AUDIO, &audioStreamHandle);
    }

    
}

int32_t getKeys(int32_t count, uint8_t* buf, int32_t* eventsRead)
{
    int32_t ret = 0;
    
    /* read input events and put them in buffer */
    ret = read(inputFileDesc, buf, (size_t)(count * (int)sizeof(struct input_event)));
    if(ret <= 0)
    {
        printf("Error code %d", ret);
        return ERROR;
    }
    /* calculate number of read events */
    *eventsRead = ret / (int)sizeof(struct input_event);
    
    return NO_ERROR;
}

void timerInit(){
    //reći OS-u da notifikaciju šalje pozivanjem specificirane funkcije iz posebne niti
    signalEvent.sigev_notify = SIGEV_THREAD; 
    //funkcija koju će OS prozvati kada interval istekne
    signalEvent.sigev_notify_function = clearChannel; 
    //argumenti funkcije
    signalEvent.sigev_value.sival_ptr = NULL;
    //atributi niti - if NULL default attributes are applied
    signalEvent.sigev_notify_attributes = NULL; 
    timer_create(/*sistemski sat za mjerenje vremena*/ CLOCK_REALTIME,                
                /*podešavanja timer-a*/ &signalEvent,                      
            /*mjesto gdje će se smjestiti ID novog timer-a*/ &timerId);

    //brisanje strukture prije setiranja vrijednosti
    memset(&timerSpec,0,sizeof(timerSpec));

    //specificiranje vremenskih podešavanja timer-a
    timerSpec.it_value.tv_sec = 3;
    timerSpec.it_value.tv_nsec = 0;

    //reći OS-u da notifikaciju šalje pozivanjem specificirane funkcije iz posebne niti
    signalEvent2.sigev_notify = SIGEV_THREAD; 
    //funkcija koju će OS prozvati kada interval istekne
    signalEvent2.sigev_notify_function = clearVolume; 
    //argumenti funkcije
    signalEvent2.sigev_value.sival_ptr = NULL;
    //atributi niti - if NULL default attributes are applied
    signalEvent2.sigev_notify_attributes = NULL; 
    timer_create(/*sistemski sat za mjerenje vremena*/ CLOCK_REALTIME,                
                /*podešavanja timer-a*/ &signalEvent2,                      
            /*mjesto gdje će se smjestiti ID novog timer-a*/ &timerId2);

    signalEvent4.sigev_notify = SIGEV_THREAD; 
    signalEvent4.sigev_notify_function = displayReminderDialog; 
    signalEvent4.sigev_value.sival_ptr = NULL; 
    signalEvent4.sigev_notify_attributes = NULL; 
    timer_create(CLOCK_REALTIME, &signalEvent4, &timerId4);

    //brisanje strukture prije setiranja vrijednosti
    memset(&timerSpec2,0,sizeof(timerSpec2));

    //specificiranje vremenskih podešavanja timer-a
    timerSpec2.it_value.tv_sec = 3; //3 seconds timeout
    timerSpec2.it_value.tv_nsec = 0;
}


void DFBInit(int32_t* argc, char*** argv){
    /* initialize DirectFB */
    
	DFBCHECK(DirectFBInit(argc, argv));
    /* fetch the DirectFB interface */
	DFBCHECK(DirectFBCreate(&dfbInterface));
    /* tell the DirectFB to take the full screen for this application */
	DFBCHECK(dfbInterface->SetCooperativeLevel(dfbInterface, DFSCL_FULLSCREEN));
	
    
    /* create primary surface with double buffering enabled */
    
	surfaceDesc.flags = DSDESC_CAPS;
	surfaceDesc.caps = DSCAPS_PRIMARY | DSCAPS_FLIPPING;
	DFBCHECK (dfbInterface->CreateSurface(dfbInterface, &surfaceDesc, &primary));
    
    
    /* fetch the screen size */
    DFBCHECK (primary->GetSize(primary, &screenWidth, &screenHeight));
    
    
    /* clear the screen before drawing anything (draw black full screen rectangle)*/
    
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0x00));
	DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 0,
                                    /*upper left y coordinate*/ 0,
                                    /*rectangle width*/ screenWidth,
                                    /*rectangle height*/ screenHeight));
	

	
	
    /* specify the height of the font by raising the appropriate flag and setting the height value */
	fontDesc.flags = DFDESC_HEIGHT;
	fontDesc.height = 70;
	
    /* create the font and set the created font for primary surface text drawing */
	DFBCHECK(dfbInterface->CreateFont(dfbInterface, "/home/galois/fonts/DejaVuSans.ttf", &fontDesc, &fontInterface));
	DFBCHECK(primary->SetFont(primary, fontInterface));

    /* switch between the displayed and the work buffer (update the display) */
	DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
}

void crniPravokutnik(){
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0xff));
    DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 0,
                                    /*upper left y coordinate*/ 0,
                                    /*rectangle width*/ screenWidth,
                                    /*rectangle height*/ screenHeight));
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0xff,
                               /*green*/ 0xff,
                               /*blue*/ 0xff,
                               /*alpha*/ 0xff));
    fontDesc.height = 70;
    DFBCHECK(dfbInterface->CreateFont(dfbInterface, "/home/galois/fonts/DejaVuSans.ttf", &fontDesc, &fontInterface));
	DFBCHECK(primary->SetFont(primary, fontInterface));
    DFBCHECK(primary->DrawString(primary,
                                 /*text to be drawn*/ "Radio kanal",
                                 /*number of bytes in the string, -1 for NULL terminated strings*/ -1,
                                 /*x coordinate of the lower left corner of the resulting text*/ screenWidth/2,
                                 /*y coordinate of the lower left corner of the resulting text*/ screenHeight/2-300,
                                 /*in case of multiple lines, allign text to left*/ DSTF_CENTER));
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0xff));
    DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 0,
                                    /*upper left y coordinate*/ 0,
                                    /*rectangle width*/ screenWidth,
                                    /*rectangle height*/ screenHeight));
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0xff,
                               /*green*/ 0xff,
                               /*blue*/ 0xff,
                               /*alpha*/ 0xff));
    DFBCHECK(primary->DrawString(primary,
                                 /*text to be drawn*/ "Radio kanal",
                                 /*number of bytes in the string, -1 for NULL terminated strings*/ -1,
                                 /*x coordinate of the lower left corner of the resulting text*/ screenWidth/2,
                                 /*y coordinate of the lower left corner of the resulting text*/ screenHeight/2-300,
                                 /*in case of multiple lines, allign text to left*/ DSTF_CENTER));
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
}

void clearScreen(){
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0x00));
    DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 0,
                                    /*upper left y coordinate*/ 0,
                                    /*rectangle width*/ screenWidth,
                                    /*rectangle height*/ screenHeight));
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
    DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 0,
                                    /*upper left y coordinate*/ 0,
                                    /*rectangle width*/ screenWidth,
                                    /*rectangle height*/ screenHeight));
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
}

void clearChannel(){
    int isRadio=(!tablePMT[channel].videoPID);
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0x00)); 
    }
	DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 100,
                                    /*upper left y coordinate*/ 800,
                                    /*rectangle width*/ 310,
                                    /*rectangle height*/ 210));
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
    DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 100,
                                    /*upper left y coordinate*/ 800,
                                    /*rectangle width*/ 310,
                                    /*rectangle height*/ 210));
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
}

void clearVolume(){
    int isRadio=(!tablePMT[channel].videoPID);
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0x00)); 
    }
	DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ screenWidth/2-100,
                                    /*upper left y coordinate*/ screenHeight/2-100,
                                    /*rectangle width*/ 200,
                                    /*rectangle height*/ 200));
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
    DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ screenWidth/2-100,
                                    /*upper left y coordinate*/ screenHeight/2-100,
                                    /*rectangle width*/ 200,
                                    /*rectangle height*/ 200));
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
}

void clearTimeDisplay() {
    // Assuming the time is displayed in the top right corner
    int posX = screenWidth - 410;
    int posY = 100;
    int width = 200; // Width of the area to clear
    int height = 200; // Height of the area to clear

    DFBCHECK(primary->SetColor(primary, 0x00, 0x00, 0x00, 0x00));
    DFBCHECK(primary->FillRectangle(primary, posX, posY, width, height));
    DFBCHECK(primary->Flip(primary, NULL, 0));
}

void scheduleReminder(int remindAtHour, int remindAtMinute) {
    struct timeval now;
    struct timespec remindTimeSpec;
    reminderActive = 1;

    gettimeofday(&now, NULL);
    struct tm *currentTime = localtime(&now.tv_sec);

    // Calculate the number of seconds until the reminder time
    int secondsUntilReminder = (remindAtHour - currentTime->tm_hour) * 3600 
                               + (remindAtMinute - currentTime->tm_min) * 60 
                               - currentTime->tm_sec;

    // If the reminder time is in the past, set it for the next day
    if (secondsUntilReminder < 0) {
        secondsUntilReminder += 24 * 3600; // Add 24 hours
    }

    remindTimeSpec.tv_sec = now.tv_sec + secondsUntilReminder;
    remindTimeSpec.tv_nsec = 0;

    // Set the timer for the reminder
    signalEvent4.sigev_notify = SIGEV_THREAD;
    signalEvent4.sigev_notify_function = displayReminderDialog;
    signalEvent4.sigev_value.sival_ptr = NULL;
    signalEvent4.sigev_notify_attributes = NULL;
    timer_create(CLOCK_REALTIME, &signalEvent4, &timerId4);

    // Zero out the timerSpec4 structure before setting it
    memset(&timerSpec4, 0, sizeof(timerSpec4));
    timerSpec4.it_value.tv_sec = secondsUntilReminder;
    timerSpec4.it_value.tv_nsec = 0;
    
    // Set the timer to be relative (TIMER_ABSTIME is for absolute time)
    timer_settime(timerId4, 0, &timerSpec4, NULL);
}




void drawTime() {
    struct timeval now;
    gettimeofday(&now, NULL);
    struct tm *t = localtime(&now.tv_sec);  // Convert time_t to struct tm

    char timeStr[10];
    strftime(timeStr, sizeof(timeStr)-1, "%H:%M", t);

    // Positioning the rhombus in the top right corner
    int posX = screenWidth - 210; // 210 pixels from the right edge
    int posY = 100;  // 100 pixels from the top

    // Set color for the rhombus
    DFBCHECK(primary->SetColor(primary, 0x70, 0x00, 0x70, 0xff)); // Purple color

    // Draw the rhombus
    primary->FillTriangle(primary, posX, posY, posX + 100, posY + 100, posX - 100, posY + 100);
    primary->FillTriangle(primary, posX, posY + 200, posX - 100, posY + 100, posX + 100, posY + 100);

    // Set color for the text
    DFBCHECK(primary->SetColor(primary, 0xff, 0xff, 0xff, 0xff)); // White color

    // Set font size for the time text
    fontDesc.height = 40; // Adjust font size if needed
    DFBCHECK(dfbInterface->CreateFont(dfbInterface, "/home/galois/fonts/DejaVuSans.ttf", &fontDesc, &fontInterface));
    DFBCHECK(primary->SetFont(primary, fontInterface));

    // Draw the time string inside the rhombus
    DFBCHECK(primary->DrawString(primary, timeStr, -1, posX, posY + 100, DSTF_CENTER));

    // Flip the primary surface to update the display
    DFBCHECK(primary->Flip(primary, NULL, 0));

    signalEvent3.sigev_notify = SIGEV_THREAD;
    signalEvent3.sigev_notify_function = clearTimeDisplay;
    signalEvent3.sigev_value.sival_ptr = NULL;
    signalEvent3.sigev_notify_attributes = NULL;
    timer_create(CLOCK_REALTIME, &signalEvent3, &timerId3);

    timerSpec3.it_value.tv_sec = 3; // 3 seconds
    timerSpec3.it_value.tv_nsec = 0;
    timer_settime(timerId3, 0, &timerSpec3, NULL);
}

void displayReminderDialog(union sigval sv) {
    // Display the reminder dialog
    drawReminderDialog("Reminder Activated!", "Switch to Channel 4?", "YES", "NO", 1);
}


void drawReminderDialog(const char* messageLine1, const char* messageLine2, const char* firstOption, const char* secondOption, int highlight) {
    // Define center of the screen
    int centerX = screenWidth / 2;
    int centerY = screenHeight / 2;
    int size = 200;
    int stretchFactor = 2.5; // Factor to stretch the rhombus horizontally
    int horizontalSide = 250;
    int verticalSide = 180;

    // Define the size of the hexagon (distance from center to any vertex)
    //int size = 100; // Change this value as needed for your desired size
    int i;
    // Calculate the vertices of the hexagon
    DFBPoint vertices[6];
    for (i = 0; i < 6; ++i) {
         vertices[i].x = centerX + (size * cos(i * 2 * M_PI / 6)) * (i % 3 == 0 ? stretchFactor : 1);
        vertices[i].y = centerY + size * sin(i * 2 * M_PI / 6);
    }

    DFBCHECK(primary->SetColor(primary, 0x70, 0x00, 0x70, 0x80)); // Color for the hexagon
    for (i = 0; i < 6; ++i) {
        DFBCHECK(primary->FillTriangle(
            primary,
            centerX,
            centerY,
            vertices[i].x,
            vertices[i].y,
            vertices[(i + 1) % 6].x,
            vertices[(i + 1) % 6].y
        ));
    }

    // Define positions for YES and NO options inside the hexagon
    int optionYesX = centerX - size / 4;
    int optionNoX = centerX + size / 4;
    int optionsY = centerY + size / 4;  // Vertical position is the same for both options


    // Set font for text
    fontDesc.height = 32;
    DFBCHECK(dfbInterface->CreateFont(dfbInterface, "/home/galois/fonts/DejaVuSans.ttf", &fontDesc, &fontInterface));
    DFBCHECK(primary->SetFont(primary, fontInterface));

  // Calculate the vertical position offsets based on font size
    int lineSpacing = fontDesc.height + 10; // 10 pixels spacing between lines
    int firstLineY = centerY - verticalSide / 4; // Adjust as needed
    int secondLineY = firstLineY + lineSpacing; // Position of second line

    // Draw the message text
    DFBCHECK(primary->SetColor(primary, 0xff, 0xff, 0xff, 0xff)); // White color for the text
    DFBCHECK(primary->DrawString(primary, messageLine1, -1, centerX, firstLineY, DSTF_CENTER));
    DFBCHECK(primary->DrawString(primary, messageLine2, -1, centerX, secondLineY, DSTF_CENTER));

     // Draw the first option (YES)
    DFBCHECK(primary->SetColor(primary, highlight == 1 ? 0xff : 0xff, highlight == 1 ? 0xff : 0xff, highlight == 1 ? 0x00 : 0xff, 0xff));
    DFBCHECK(primary->DrawString(primary, firstOption, -1, optionYesX, optionsY, DSTF_CENTER));

    // Draw the second option (NO)
    DFBCHECK(primary->SetColor(primary, highlight == 2 ? 0xff : 0xff, highlight == 2 ? 0xff : 0xff, highlight == 2 ? 0x00 : 0xff, 0xff));
    DFBCHECK(primary->DrawString(primary, secondOption, -1, optionNoX, optionsY, DSTF_CENTER));

 // Draw rectangles around options if highlighted
    if (highlight == 1) {
        // Rectangle around "YES"
        DFBCHECK(primary->DrawRectangle(primary, optionYesX - size / 8, optionsY - fontDesc.height / 2, size / 4, fontDesc.height));
    } else if (highlight == 2) {
        // Rectangle around "NO"
        DFBCHECK(primary->DrawRectangle(primary, optionNoX - size / 8, optionsY - fontDesc.height / 2, size / 4, fontDesc.height));
    }
    // Flip the primary surface to update the display
    DFBCHECK(primary->Flip(primary, NULL, 0));
}




void drawChannel(int channel, int hasTTX, int isRadio){
    char str[10];
    sprintf(str, "%d", channel);
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0xff));
    }
    else{
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0x00)); 
    }
	DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 100,
                                    /*upper left y coordinate*/ 800,
                                    /*rectangle width*/ 310,
                                    /*rectangle height*/ 210));
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x70,
                               /*green*/ 0x00,
                               /*blue*/ 0x70,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x70,
                               /*green*/ 0x00,
                               /*blue*/ 0x70,
                               /*alpha*/ 0xbb));
    }
    primary->FillTriangle(primary, 200, 800, 300, 900, 100, 900);
    primary->FillTriangle(primary, 200, 1000, 100, 900, 300, 900);
    if(hasTTX){
        primary->FillTriangle(primary, 310, 910, 360, 960, 260, 960);
        primary->FillTriangle(primary, 310, 1010, 260, 960, 360, 960);
    }
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0xff,
                               /*green*/ 0xff,
                               /*blue*/ 0xff,
                               /*alpha*/ 0xff));
    fontDesc.height = 70;
    DFBCHECK(dfbInterface->CreateFont(dfbInterface, "/home/galois/fonts/DejaVuSans.ttf", &fontDesc, &fontInterface));
	DFBCHECK(primary->SetFont(primary, fontInterface));
    DFBCHECK(primary->DrawString(primary,
                                 /*text to be drawn*/ "Ch",
                                 /*number of bytes in the string, -1 for NULL terminated strings*/ -1,
                                 /*x coordinate of the lower left corner of the resulting text*/ 200,
                                 /*y coordinate of the lower left corner of the resulting text*/ 900,
                                 /*in case of multiple lines, allign text to left*/ DSTF_CENTER));
    DFBCHECK(primary->DrawString(primary,
                                 /*text to be drawn*/ str,
                                 /*number of bytes in the string, -1 for NULL terminated strings*/ -1,
                                 /*x coordinate of the lower left corner of the resulting text*/ 200,
                                 /*y coordinate of the lower left corner of the resulting text*/ 970,
                                 /*in case of multiple lines, allign text to left*/ DSTF_CENTER));
    if(hasTTX){
        fontDesc.height = 35;
        DFBCHECK(dfbInterface->CreateFont(dfbInterface, "/home/galois/fonts/DejaVuSans.ttf", &fontDesc, &fontInterface));
	    DFBCHECK(primary->SetFont(primary, fontInterface));
        DFBCHECK(primary->DrawString(primary,
                                 /*text to be drawn*/ "TTX",
                                 /*number of bytes in the string, -1 for NULL terminated strings*/ -1,
                                 /*x coordinate of the lower left corner of the resulting text*/ 310,
                                 /*y coordinate of the lower left corner of the resulting text*/ 980,
                                 /*in case of multiple lines, allign text to left*/ DSTF_CENTER));
    }
    
	DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0x00)); 
    }
	DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ 100,
                                    /*upper left y coordinate*/ 800,
                                    /*rectangle width*/ 310,
                                    /*rectangle height*/ 210));
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x70,
                               /*green*/ 0x00,
                               /*blue*/ 0x70,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x70,
                               /*green*/ 0x00,
                               /*blue*/ 0x70,
                               /*alpha*/ 0xbb));
    }
    primary->FillTriangle(primary, 200, 800, 300, 900, 100, 900);
    primary->FillTriangle(primary, 200, 1000, 100, 900, 300, 900);

    if(hasTTX){
        primary->FillTriangle(primary, 310, 910, 360, 960, 260, 960);
        primary->FillTriangle(primary, 310, 1010, 260, 960, 360, 960);
    }
    fontDesc.height = 70;
    DFBCHECK(dfbInterface->CreateFont(dfbInterface, "/home/galois/fonts/DejaVuSans.ttf", &fontDesc, &fontInterface));
	DFBCHECK(primary->SetFont(primary, fontInterface));
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0xff,
                               /*green*/ 0xff,
                               /*blue*/ 0xff,
                               /*alpha*/ 0xff));
    DFBCHECK(primary->DrawString(primary,
                                 /*text to be drawn*/ "Ch",
                                 /*number of bytes in the string, -1 for NULL terminated strings*/ -1,
                                 /*x coordinate of the lower left corner of the resulting text*/ 200,
                                 /*y coordinate of the lower left corner of the resulting text*/ 900,
                                 /*in case of multiple lines, allign text to left*/ DSTF_CENTER));
    DFBCHECK(primary->DrawString(primary,
                                 /*text to be drawn*/ str,
                                 /*number of bytes in the string, -1 for NULL terminated strings*/ -1,
                                 /*x coordinate of the lower left corner of the resulting text*/ 200,
                                 /*y coordinate of the lower left corner of the resulting text*/ 970,
                                 /*in case of multiple lines, allign text to left*/ DSTF_CENTER));
    if(hasTTX){
        fontDesc.height = 35;
        DFBCHECK(dfbInterface->CreateFont(dfbInterface, "/home/galois/fonts/DejaVuSans.ttf", &fontDesc, &fontInterface));
	    DFBCHECK(primary->SetFont(primary, fontInterface));
        DFBCHECK(primary->DrawString(primary,
                                 /*text to be drawn*/ "TTX",
                                 /*number of bytes in the string, -1 for NULL terminated strings*/ -1,
                                 /*x coordinate of the lower left corner of the resulting text*/ 310,
                                 /*y coordinate of the lower left corner of the resulting text*/ 980,
                                 /*in case of multiple lines, allign text to left*/ DSTF_CENTER));
    }
    
	DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
}






void drawVolume(int vol, int isRadio){
    
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0x00)); 
    }
	DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ screenWidth/2-100,
                                    /*upper left y coordinate*/ screenHeight/2-100,
                                    /*rectangle width*/ 200,
                                    /*rectangle height*/ 200));
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x70,
                               /*green*/ 0x00,
                               /*blue*/ 0x70,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x70,
                               /*green*/ 0x00,
                               /*blue*/ 0x70,
                               /*alpha*/ 0xbb));
    }
    
                               
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2)-100, (screenWidth/2)+100, (screenHeight/2), (screenWidth/2)-100, (screenHeight/2));
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2)+100, (screenWidth/2)-100, (screenHeight/2), (screenWidth/2)+100, (screenHeight/2));
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0xff,
                               /*green*/ 0xff,
                               /*blue*/ 0xff,
                               /*alpha*/ 0xff));

    float firstScale=vol/25.0;
    float secondScale=(vol-25)/25.0;
    float thirdScale=(vol-50)/25.0;
    float fourthScale=(vol-75)/25.0;

    // truncate the negative values to 0
    secondScale = secondScale < 0 ? 0 : secondScale;
    thirdScale = thirdScale < 0 ? 0 : thirdScale;
    fourthScale = fourthScale < 0 ? 0 : fourthScale;

    // truncate the values to 1
    firstScale = firstScale > 1 ? 1 : firstScale;
    secondScale = secondScale > 1 ? 1 : secondScale;
    thirdScale = thirdScale > 1 ? 1 : thirdScale;
    fourthScale = fourthScale > 1 ? 1 : fourthScale;



    primary->FillTriangle(primary, (screenWidth/2)-1, (screenHeight/2)-90, (screenWidth/2), (screenHeight/2), (screenWidth/2)+90*firstScale-1, (screenHeight/2)-90+90*firstScale);
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2), (screenWidth/2)+90, (screenHeight/2), (screenWidth/2)+90-90*secondScale, (screenHeight/2)+90*secondScale);
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2), (screenWidth/2)-1, (screenHeight/2)+90, (screenWidth/2)-90*thirdScale-1, (screenHeight/2)+90-90*thirdScale);
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2), (screenWidth/2)-90, (screenHeight/2), (screenWidth/2)-90+90*fourthScale, (screenHeight/2)-90*fourthScale);
   

	DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x00,
                               /*green*/ 0x00,
                               /*blue*/ 0x00,
                               /*alpha*/ 0x00)); 
    }
	DFBCHECK(primary->FillRectangle(/*surface to draw on*/ primary,
                                    /*upper left x coordinate*/ screenWidth/2-100,
                                    /*upper left y coordinate*/ screenHeight/2-100,
                                    /*rectangle width*/ 200,
                                    /*rectangle height*/ 200));
    //draw again on other buffer
    if(isRadio){
        DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x70,
                               /*green*/ 0x00,
                               /*blue*/ 0x70,
                               /*alpha*/ 0xff));
    }
    else{
       DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0x70,
                               /*green*/ 0x00,
                               /*blue*/ 0x70,
                               /*alpha*/ 0xbb));
    }
                               
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2)-100, (screenWidth/2)+100, (screenHeight/2), (screenWidth/2)-100, (screenHeight/2));
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2)+100, (screenWidth/2)-100, (screenHeight/2), (screenWidth/2)+100, (screenHeight/2));
    DFBCHECK(primary->SetColor(/*surface to draw on*/ primary,
                               /*red*/ 0xff,
                               /*green*/ 0xff,
                               /*blue*/ 0xff,
                               /*alpha*/ 0xff));
    primary->FillTriangle(primary, (screenWidth/2)-1, (screenHeight/2)-90, (screenWidth/2), (screenHeight/2), (screenWidth/2)+90*firstScale-1, (screenHeight/2)-90+90*firstScale);
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2), (screenWidth/2)+90, (screenHeight/2), (screenWidth/2)+90-90*secondScale, (screenHeight/2)+90*secondScale);
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2), (screenWidth/2)-1, (screenHeight/2)+90, (screenWidth/2)-1-90*thirdScale, (screenHeight/2)+90-90*thirdScale);
    primary->FillTriangle(primary, (screenWidth/2), (screenHeight/2), (screenWidth/2)-90, (screenHeight/2), (screenWidth/2)-90+90*fourthScale, (screenHeight/2)-90*fourthScale);
    
    
    DFBCHECK(primary->Flip(primary,
                           /*region to be updated, NULL for the whole surface*/NULL,
                           /*flip flags*/0));
}



int32_t getKeys(int32_t count, uint8_t* buf, int32_t* eventRead);
